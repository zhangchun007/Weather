package com.zhangsheng.shunxin.weather.utilsimport android.content.Contextimport android.graphics.Bitmapimport android.graphics.BitmapFactoryimport android.location.Addressimport android.location.Geocoderimport android.view.Viewimport android.widget.ImageViewimport android.widget.TextViewimport com.amap.api.location.CoordinateConverterimport com.amap.api.maps.AMapimport com.amap.api.maps.model.*import com.maiya.thirdlibrary.ext.listIndeximport com.maiya.thirdlibrary.ext.scaleimport com.maiya.thirdlibrary.utils.AppContextimport com.maiya.thirdlibrary.utils.PicUtilsimport com.zhangsheng.shunxin.Rimport com.zhangsheng.shunxin.weather.net.bean.AirPositionBeanimport java.io.IOExceptionimport java.io.InputStreamimport java.util.*import kotlin.math.atan2import kotlin.math.cosimport kotlin.math.sinimport kotlin.math.sqrt/** * Created by Quan on 2018/8/22 0022 15:51 * E-Mail Address：672114236@qq.com */object MapUtils {    fun drawMarker(latLng: LatLng, res: Int, isVisit: Boolean = true): MarkerOptions {        val markerOption = MarkerOptions()        markerOption            .position(latLng)            .visible(isVisit)            .anchor(0.5f, 1.0f)            .icon(                BitmapDescriptorFactory.fromBitmap(                    BitmapFactory.decodeResource(AppContext.getContext().resources, res)                )            )        markerOption.isFlat = false        return markerOption    }    /**     * 往地图上添加marker     */    fun addAirMarkersToMap(        context: Context,        aMap: AMap,        latlng: LatLng,        bean: AirPositionBean.Postion,        isBig: Boolean = true    ): Marker {        var bitmap: Bitmap?        if (isBig) {            var view: View = View.inflate(context, R.layout.item_map_air_marker_info, null)            var bg = view.findViewById<ImageView>(R.id.bg)            var air = view.findViewById<TextView>(R.id.air)            air.text = bean.aqi            PicUtils.tintColor(bg, WeatherUtils.airColor(bean.aqiLevel).listIndex(0))            bitmap = convertViewToBitmap(view)        } else {            var view = ImageView(context)            view.setImageResource(WeatherUtils.airCircle(bean.aqiLevel))            bitmap = convertViewToBitmap(view)        }        var markerOptions = MarkerOptions()            .position(latlng)            .draggable(true)            .icon(BitmapDescriptorFactory.fromBitmap(bitmap))        return aMap.addMarker(markerOptions)    }    /**     * 往地图上添加marker     */    fun getAirMarkerBitmapDescriptor(        context: Context,        bean: AirPositionBean.Postion,        isSmall: Boolean    ): BitmapDescriptor {        return if (isSmall) {            var view = ImageView(context)            view.setImageResource(WeatherUtils.airCircle(bean.aqiLevel))            BitmapDescriptorFactory.fromView(view)        } else {            val view: View = View.inflate(context, R.layout.item_map_air_marker_info, null)            var bg = view.findViewById<ImageView>(R.id.bg)            var air = view.findViewById<TextView>(R.id.air)            air.text = bean.aqi            PicUtils.tintColor(bg, WeatherUtils.airColor(bean.aqiLevel).listIndex(0))            BitmapDescriptorFactory.fromView(view)        }    }    fun convertViewToBitmap(view: View): Bitmap? {        view.measure(            View.MeasureSpec.makeMeasureSpec(                0,                View.MeasureSpec.UNSPECIFIED            ),            View.MeasureSpec.makeMeasureSpec(                0,                View.MeasureSpec.UNSPECIFIED            )        )        view.layout(0, 0, view.measuredWidth, view.measuredHeight)        view.buildDrawingCache(false)        return view.drawingCache    }    /**     * 判断所在位置     */    fun checkLocationAvailable(latlng: LatLng): Boolean {       return CoordinateConverter.isAMapDataAvailable(           latlng.latitude,           latlng.longitude       )    }    /**     * @param latitude 经度     * @param longitude 纬度     * @return 详细位置信息 GeoCoder是基于后台backend的服务，因此这个方法不是对每台设备都适用。     */    fun GooglePlace(latLng: LatLng, context: Context): String {        val geocoder = Geocoder(context, Locale.CHINESE)        return try {            val addresses: List<Address> =                geocoder.getFromLocation(latLng.latitude, latLng.longitude, 1)            if (addresses.isNotEmpty()) {                var address: Address = addresses.listIndex(0)                address.adminArea            } else {                "N${latLng.latitude.scale(2)}°，E${latLng.longitude.scale(2)}°"            }        } catch (e: IOException) {            e.printStackTrace()            "N${latLng.latitude.scale(2)}°，E${latLng.longitude.scale(2)}°"        }    }    /**     * 高德坐标转换成百度坐标     */    fun gdConvertBd(gg_lng: Double, gg_lat: Double) :LatLng{        var X_PI = Math.PI * 3000.0 / 180.0        var x = gg_lng        var y = gg_lat        var z = Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * X_PI)        var theta = Math.atan2(y, x) + 0.000003 * Math.cos(x * X_PI)        var bd_lng = z * Math.cos(theta) + 0.0065        var bd_lat = z * Math.sin(theta) + 0.006        var latlng=LatLng(bd_lat, bd_lng)        return latlng    }    fun bdConvertGd(lat: Double, lng: Double):LatLng{        var X_PI = Math.PI * 3000.0 / 180.0        var x = lng - 0.0065        var y = lat - 0.006        var z = sqrt(x * x + y * y) - 0.00002 * sin(y * X_PI)        var theta = atan2(y, x) - 0.000003 * cos(x * X_PI)        var gg_lng = z * cos(theta)        var gg_lat = z * sin(theta)       return LatLng(gg_lat, gg_lng)    }    /**     * 根据经纬度获取地理位置     */    fun getAddress(latLng: LatLng, context: Context): Address? {        val geocoder = Geocoder(context, Locale.CHINESE)        return try {            val addresses: List<Address> =                geocoder.getFromLocation(latLng.latitude, latLng.longitude, 1)            if (addresses.isNotEmpty()) {                var address: Address = addresses.listIndex(0)                address            } else {                null            }        } catch (e: IOException) {            e.printStackTrace()            null        }    }    fun getAssetsStyle(context: Context,FileStr:String): ByteArray? {        var buffer1: ByteArray? = null        var is1: InputStream? = null        try {            is1 = context.resources.assets.open(FileStr)            val lenght1: Int = is1.available()            buffer1 = ByteArray(lenght1)            is1.read(buffer1)        } catch (e: IOException) {            e.printStackTrace()        } finally {            try {                is1?.close()            } catch (e: IOException) {                e.printStackTrace()            }        }        return buffer1    }}